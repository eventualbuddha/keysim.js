(function (global, factory) {
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  typeof exports === 'object' ? factory(exports) :
  (global.Keysim = {}, factory(global.Keysim))
}(this, function (exports) { 'use strict';

  var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

  /* jshint esnext:true, undef:true, unused:true */

  var CTRL = 1 << 0;
  var META = 1 << 1;
  var ALT = 1 << 2;
  var SHIFT = 1 << 3;

  /**
   * Represents a keystroke, or a single key code with a set of active modifiers.
   *
   * @class Keystroke
   */
  var Keystroke = (function () {
    /**
     * @param {number} modifiers A bitmask formed by CTRL, META, ALT, and SHIFT.
     * @param {number} keyCode
     */

    function Keystroke(modifiers, keyCode) {
      _classCallCheck(this, Keystroke);

      this.modifiers = modifiers;
      this.ctrlKey = !!(modifiers & CTRL);
      this.metaKey = !!(modifiers & META);
      this.altKey = !!(modifiers & ALT);
      this.shiftKey = !!(modifiers & SHIFT);
      this.keyCode = keyCode;
    }

    Keystroke.CTRL = CTRL;
    Keystroke.META = META;
    Keystroke.ALT = ALT;
    Keystroke.SHIFT = SHIFT;
    return Keystroke;
  })();

  /**
   * Simulates a keyboard with a particular key-to-character and key-to-action
   * mapping. Use `US_ENGLISH` to get a pre-configured keyboard.
   */
  var Keyboard = (function () {
    /**
     * @param {Object.<number, Keystroke>} charCodeKeyCodeMap
     * @param {Object.<string, number>} actionKeyCodeMap
     */

    function Keyboard(charCodeKeyCodeMap, actionKeyCodeMap) {
      _classCallCheck(this, Keyboard);

      this._charCodeKeyCodeMap = charCodeKeyCodeMap;
      this._actionKeyCodeMap = actionKeyCodeMap;
    }

    /**
     * Determines the character code generated by pressing the given keystroke.
     *
     * @param {Keystroke} keystroke
     * @return {?number}
     */

    Keyboard.prototype.charCodeForKeystroke = function charCodeForKeystroke(keystroke) {
      var map = this._charCodeKeyCodeMap;
      for (var charCode in map) {
        if (Object.prototype.hasOwnProperty.call(map, charCode)) {
          var keystrokeForCharCode = map[charCode];
          if (keystroke.keyCode === keystrokeForCharCode.keyCode && keystroke.modifiers === keystrokeForCharCode.modifiers) {
            return parseInt(charCode, 10);
          }
        }
      }
      return null;
    };

    /**
     * Creates an event ready for dispatching onto the given target.
     *
     * @param {string} type One of "keydown", "keypress", "keyup", or "textInput".
     * @param {Keystroke} keystroke
     * @param {HTMLElement} target
     * @return {Event}
     */

    Keyboard.prototype.createEventFromKeystroke = function createEventFromKeystroke(type, keystroke, target) {
      var document = target.ownerDocument;
      var window = document.defaultView;
      var Event = window.Event;

      var event = undefined;

      try {
        event = new Event(type);
      } catch (e) {
        event = document.createEvent("UIEvents");
      }

      event.initEvent(type, true, true);

      switch (type) {
        case "textInput":
          event.data = String.fromCharCode(this.charCodeForKeystroke(keystroke));
          break;

        case "keydown":case "keypress":case "keyup":
          event.shiftKey = keystroke.shiftKey;
          event.altKey = keystroke.altKey;
          event.metaKey = keystroke.metaKey;
          event.ctrlKey = keystroke.ctrlKey;
          event.keyCode = type === "keypress" ? this.charCodeForKeystroke(keystroke) : keystroke.keyCode;
          event.charCode = type === "keypress" ? event.keyCode : 0;
          event.which = event.keyCode;
          break;
      }

      return event;
    };

    /**
     * Fires the correct sequence of events on the given target as if the given
     * action was undertaken by a human.
     *
     * @param {string} action e.g. "alt+shift+left" or "backspace"
     * @param {HTMLElement} target
     */

    Keyboard.prototype.dispatchEventsForAction = function dispatchEventsForAction(action, target) {
      var keystroke = this.keystrokeForAction(action);
      this.dispatchEventsForKeystroke(keystroke, target);
    };

    /**
     * Fires the correct sequence of events on the given target as if the given
     * input had been typed by a human.
     *
     * @param {string} input
     * @param {HTMLElement} target
     */

    Keyboard.prototype.dispatchEventsForInput = function dispatchEventsForInput(input, target) {
      var currentModifierState = 0;
      for (var i = 0, _length = input.length; i < _length; i++) {
        var keystroke = this.keystrokeForCharCode(input.charCodeAt(i));
        this.dispatchModifierStateTransition(target, currentModifierState, keystroke.modifiers);
        this.dispatchEventsForKeystroke(keystroke, target, false);
        currentModifierState = keystroke.modifiers;
      }
      this.dispatchModifierStateTransition(target, currentModifierState, 0);
    };

    /**
     * Fires the correct sequence of events on the given target as if the given
     * keystroke was performed by a human. When simulating, for example, typing
     * the letter "A" (assuming a U.S. English keyboard) then the sequence will
     * look like this:
     *
     *   keydown   keyCode=16 (SHIFT) charCode=0      shiftKey=true
     *   keydown   keyCode=65 (A)     charCode=0      shiftKey=true
     *   keypress  keyCode=65 (A)     charCode=65 (A) shiftKey=true
     *   textInput data=A
     *   keyup     keyCode=65 (A)     charCode=0      shiftKey=true
     *   keyup     keyCode=16 (SHIFT) charCode=0      shiftKey=false
     *
     * If the keystroke would not cause a character to be input, such as when
     * pressing alt+shift+left, the sequence looks like this:
     *
     *   keydown   keyCode=16 (SHIFT) charCode=0 altKey=false shiftKey=true
     *   keydown   keyCode=18 (ALT)   charCode=0 altKey=true  shiftKey=true
     *   keydown   keyCode=37 (LEFT)  charCode=0 altKey=true  shiftKey=true
     *   keyup     keyCode=37 (LEFT)  charCode=0 altKey=true  shiftKey=true
     *   keyup     keyCode=18 (ALT)   charCode=0 altKey=false shiftKey=true
     *   keyup     keyCode=16 (SHIFT) charCode=0 altKey=false shiftKey=false
     *
     * To disable handling of modifier keys, call with `transitionModifers` set
     * to false. Doing so will omit the keydown and keyup events associated with
     * shift, ctrl, alt, and meta keys surrounding the actual keystroke.
     *
     * @param {Keystroke} keystroke
     * @param {HTMLElement} target
     * @param {boolean=} transitionModifiers
     */

    Keyboard.prototype.dispatchEventsForKeystroke = function dispatchEventsForKeystroke(keystroke, target) {
      var transitionModifiers = arguments[2] === undefined ? true : arguments[2];

      if (transitionModifiers) {
        this.dispatchModifierStateTransition(target, 0, keystroke.modifiers);
      }

      var keydownEvent = this.createEventFromKeystroke("keydown", keystroke, target);

      if (target.dispatchEvent(keydownEvent) && this.targetCanReceiveTextInput(target)) {
        var keypressEvent = this.createEventFromKeystroke("keypress", keystroke, target);
        if (keypressEvent.charCode && target.dispatchEvent(keypressEvent)) {
          var textinputEvent = this.createEventFromKeystroke("textInput", keystroke, target);
          target.dispatchEvent(textinputEvent);
        }
      }

      var keyupEvent = this.createEventFromKeystroke("keyup", keystroke, target);
      target.dispatchEvent(keyupEvent);

      if (transitionModifiers) {
        this.dispatchModifierStateTransition(target, keystroke.modifiers, 0);
      }
    };

    /**
     * Transitions from one modifier state to another by dispatching key events.
     *
     * @param {EventTarget} target
     * @param {number} fromModifierState
     * @param {number} toModifierState
     * @private
     */

    Keyboard.prototype.dispatchModifierStateTransition = function dispatchModifierStateTransition(target, fromModifierState, toModifierState) {
      var currentModifierState = fromModifierState;
      var didHaveMeta = (fromModifierState & META) === META;
      var willHaveMeta = (toModifierState & META) === META;
      var didHaveCtrl = (fromModifierState & CTRL) === CTRL;
      var willHaveCtrl = (toModifierState & CTRL) === CTRL;
      var didHaveShift = (fromModifierState & SHIFT) === SHIFT;
      var willHaveShift = (toModifierState & SHIFT) === SHIFT;
      var didHaveAlt = (fromModifierState & ALT) === ALT;
      var willHaveAlt = (toModifierState & ALT) === ALT;

      if (didHaveMeta === true && willHaveMeta === false) {
        // Release the meta key.
        currentModifierState &= ~META;
        target.dispatchEvent(this.createEventFromKeystroke("keyup", new Keystroke(currentModifierState, this._actionKeyCodeMap.META), target));
      }

      if (didHaveCtrl === true && willHaveCtrl === false) {
        // Release the ctrl key.
        currentModifierState &= ~CTRL;
        target.dispatchEvent(this.createEventFromKeystroke("keyup", new Keystroke(currentModifierState, this._actionKeyCodeMap.CTRL), target));
      }

      if (didHaveShift === true && willHaveShift === false) {
        // Release the shift key.
        currentModifierState &= ~SHIFT;
        target.dispatchEvent(this.createEventFromKeystroke("keyup", new Keystroke(currentModifierState, this._actionKeyCodeMap.SHIFT), target));
      }

      if (didHaveAlt === true && willHaveAlt === false) {
        // Release the alt key.
        currentModifierState &= ~ALT;
        target.dispatchEvent(this.createEventFromKeystroke("keyup", new Keystroke(currentModifierState, this._actionKeyCodeMap.ALT), target));
      }

      if (didHaveMeta === false && willHaveMeta === true) {
        // Press the meta key.
        currentModifierState |= META;
        target.dispatchEvent(this.createEventFromKeystroke("keydown", new Keystroke(currentModifierState, this._actionKeyCodeMap.META), target));
      }

      if (didHaveCtrl === false && willHaveCtrl === true) {
        // Press the ctrl key.
        currentModifierState |= CTRL;
        target.dispatchEvent(this.createEventFromKeystroke("keydown", new Keystroke(currentModifierState, this._actionKeyCodeMap.CTRL), target));
      }

      if (didHaveShift === false && willHaveShift === true) {
        // Press the shift key.
        currentModifierState |= SHIFT;
        target.dispatchEvent(this.createEventFromKeystroke("keydown", new Keystroke(currentModifierState, this._actionKeyCodeMap.SHIFT), target));
      }

      if (didHaveAlt === false && willHaveAlt === true) {
        // Press the alt key.
        currentModifierState |= ALT;
        target.dispatchEvent(this.createEventFromKeystroke("keydown", new Keystroke(currentModifierState, this._actionKeyCodeMap.ALT), target));
      }

      if (currentModifierState !== toModifierState) {
        throw new Error("internal error, expected modifier state: " + toModifierState + (", got: " + currentModifierState));
      }
    };

    /**
     * Returns the keystroke associated with the given action.
     *
     * @param {string} action
     * @return {?Keystroke}
     */

    Keyboard.prototype.keystrokeForAction = function keystrokeForAction(action) {
      var keyCode = null;
      var modifiers = 0;

      var parts = action.split("+");
      var lastPart = parts.pop();

      parts.forEach(function (part) {
        switch (part.toUpperCase()) {
          case "CTRL":
            modifiers |= CTRL;break;
          case "META":
            modifiers |= META;break;
          case "ALT":
            modifiers |= ALT;break;
          case "SHIFT":
            modifiers |= SHIFT;break;
          default:
            throw new Error("in \"" + action + "\", invalid modifier: " + part);
            break;
        }
      });

      if (lastPart.toUpperCase() in this._actionKeyCodeMap) {
        keyCode = this._actionKeyCodeMap[lastPart.toUpperCase()];
      } else if (lastPart.length === 1) {
        var lastPartKeystroke = this.keystrokeForCharCode(lastPart.charCodeAt(0));
        modifiers |= lastPartKeystroke.modifiers;
        keyCode = lastPartKeystroke.keyCode;
      } else {
        throw new Error("in \"" + action + "\", invalid action: " + lastPart);
      }

      return new Keystroke(modifiers, keyCode);
    };

    /**
     * Gets the keystroke used to generate the given character code.
     *
     * @param {number} charCode
     * @return {?Keystroke}
     */

    Keyboard.prototype.keystrokeForCharCode = function keystrokeForCharCode(charCode) {
      return this._charCodeKeyCodeMap[charCode] || null;
    };

    /**
     * @param {EventTarget} target
     * @private
     */

    Keyboard.prototype.targetCanReceiveTextInput = function targetCanReceiveTextInput(target) {
      if (!target) {
        return false;
      }

      switch (target.nodeName && target.nodeName.toLowerCase()) {
        case "input":
          var type = target.type;
          return !(type === "hidden" || type === "radio" || type === "checkbox");

        case "textarea":
          return true;

        default:
          return false;
      }
    };

    return Keyboard;
  })();

  var US_ENGLISH_CHARCODE_KEYCODE_MAP = {
    32: new Keystroke(0, 32), // <space>
    33: new Keystroke(SHIFT, 49), // !
    34: new Keystroke(SHIFT, 222), // "
    35: new Keystroke(SHIFT, 51), // #
    36: new Keystroke(SHIFT, 52), // $
    37: new Keystroke(SHIFT, 53), // %
    38: new Keystroke(SHIFT, 55), // &
    39: new Keystroke(0, 222), // '
    40: new Keystroke(SHIFT, 57), // (
    41: new Keystroke(SHIFT, 48), // )
    42: new Keystroke(SHIFT, 56), // *
    43: new Keystroke(SHIFT, 187), // +
    44: new Keystroke(0, 188), // ,
    45: new Keystroke(0, 189), // -
    46: new Keystroke(0, 190), // .
    47: new Keystroke(0, 191), // /
    48: new Keystroke(0, 48), // 0
    49: new Keystroke(0, 49), // 1
    50: new Keystroke(0, 50), // 2
    51: new Keystroke(0, 51), // 3
    52: new Keystroke(0, 52), // 4
    53: new Keystroke(0, 53), // 5
    54: new Keystroke(0, 54), // 6
    55: new Keystroke(0, 55), // 7
    56: new Keystroke(0, 56), // 8
    57: new Keystroke(0, 57), // 9
    58: new Keystroke(SHIFT, 186), // :
    59: new Keystroke(0, 186), // ;
    60: new Keystroke(SHIFT, 188), // <
    61: new Keystroke(0, 187), // =
    62: new Keystroke(SHIFT, 190), // >
    63: new Keystroke(SHIFT, 191), // ?
    64: new Keystroke(SHIFT, 50), // @
    65: new Keystroke(SHIFT, 65), // A
    66: new Keystroke(SHIFT, 66), // B
    67: new Keystroke(SHIFT, 67), // C
    68: new Keystroke(SHIFT, 68), // D
    69: new Keystroke(SHIFT, 69), // E
    70: new Keystroke(SHIFT, 70), // F
    71: new Keystroke(SHIFT, 71), // G
    72: new Keystroke(SHIFT, 72), // H
    73: new Keystroke(SHIFT, 73), // I
    74: new Keystroke(SHIFT, 74), // J
    75: new Keystroke(SHIFT, 75), // K
    76: new Keystroke(SHIFT, 76), // L
    77: new Keystroke(SHIFT, 77), // M
    78: new Keystroke(SHIFT, 78), // N
    79: new Keystroke(SHIFT, 79), // O
    80: new Keystroke(SHIFT, 80), // P
    81: new Keystroke(SHIFT, 81), // Q
    82: new Keystroke(SHIFT, 82), // R
    83: new Keystroke(SHIFT, 83), // S
    84: new Keystroke(SHIFT, 84), // T
    85: new Keystroke(SHIFT, 85), // U
    86: new Keystroke(SHIFT, 86), // V
    87: new Keystroke(SHIFT, 87), // W
    88: new Keystroke(SHIFT, 88), // X
    89: new Keystroke(SHIFT, 89), // Y
    90: new Keystroke(SHIFT, 90), // Z
    91: new Keystroke(0, 219), // [
    92: new Keystroke(0, 220), // \
    93: new Keystroke(0, 221), // ]
    96: new Keystroke(0, 192), // `
    97: new Keystroke(0, 65), // a
    98: new Keystroke(0, 66), // b
    99: new Keystroke(0, 67), // c
    100: new Keystroke(0, 68), // d
    101: new Keystroke(0, 69), // e
    102: new Keystroke(0, 70), // f
    103: new Keystroke(0, 71), // g
    104: new Keystroke(0, 72), // h
    105: new Keystroke(0, 73), // i
    106: new Keystroke(0, 74), // j
    107: new Keystroke(0, 75), // k
    108: new Keystroke(0, 76), // l
    109: new Keystroke(0, 77), // m
    110: new Keystroke(0, 78), // n
    111: new Keystroke(0, 79), // o
    112: new Keystroke(0, 80), // p
    113: new Keystroke(0, 81), // q
    114: new Keystroke(0, 82), // r
    115: new Keystroke(0, 83), // s
    116: new Keystroke(0, 84), // t
    117: new Keystroke(0, 85), // u
    118: new Keystroke(0, 86), // v
    119: new Keystroke(0, 87), // w
    120: new Keystroke(0, 88), // x
    121: new Keystroke(0, 89), // y
    122: new Keystroke(0, 90), // z
    123: new Keystroke(SHIFT, 219), // {
    124: new Keystroke(SHIFT, 220), // |
    125: new Keystroke(SHIFT, 221), // }
    126: new Keystroke(SHIFT, 192) // ~
  };

  var US_ENGLISH_ACTION_KEYCODE_MAP = {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPSLOCK: 20,
    ESCAPE: 27,
    PAGEUP: 33,
    PAGEDOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    INSERT: 45,
    DELETE: 46,
    META: 91,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123
  };

  /**
   * Gets a keyboard instance configured as a U.S. English keyboard would be.
   *
   * @return {Keyboard}
   */
  Keyboard.US_ENGLISH = new Keyboard(US_ENGLISH_CHARCODE_KEYCODE_MAP, US_ENGLISH_ACTION_KEYCODE_MAP);

  /**
   * Gets the bitmask value for the "control" modifier.
   *
   * @type {number}
   */

  /**
   * Gets the bitmask value for the "meta" modifier.
   *
   * @return {number}
   */

  /**
   * Gets the bitmask value for the "alt" modifier.
   *
   * @return {number}
   */

  /**
   * Gets the bitmask value for the "shift" modifier.
   *
   * @return {number}
   */

  exports.Keystroke = Keystroke;
  exports.Keyboard = Keyboard;

}));